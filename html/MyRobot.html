
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>MyRobot</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-03-27"><meta name="DC.source" content="MyRobot.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">classdef</span> MyRobot &lt; handle
    <span class="keyword">properties</span>
        lib_name = <span class="string">'dxl_x64_c'</span>;
        <span class="comment">%if ~libisloaded(lib_name)</span>
        <span class="comment">%    [notfound, warnings] = loadlibrary(lib_name, 'dynamixel_sdk.h', 'addheader', 'port_handler.h', 'addheader', 'packet_handler.h');</span>
        <span class="comment">%end</span>

        <span class="comment">% Control table address</span>
        ADDR_MX_TORQUE_ENABLE       = 24;           <span class="comment">% Control table address is different in Dynamixel model</span>
        ADDR_MX_GOAL_POSITION       = 30;
        ADDR_MX_PRESENT_POSITION    = 36;

        <span class="comment">% Protocol version</span>
        PROTOCOL_VERSION            = 1.0;          <span class="comment">% See which protocol version is used in the Dynamixel</span>

        motor_ids = [2 1 10 0];

        BAUDRATE                    = 1000000;
        DEVICENAME                  = <span class="string">'COM3'</span>;       <span class="comment">% Check which port is being used on your controller</span>
        <span class="comment">% ex) Windows: 'COM1'   Linux: '/dev/ttyUSB0' Mac: '/dev/tty.usbserial-*'</span>

        TORQUE_ENABLE               = 1;            <span class="comment">% Value for enabling the torque</span>
        TORQUE_DISABLE              = 0;            <span class="comment">% Value for disabling the torque</span>
        DXL_MOVING_STATUS_THRESHOLD = 10;           <span class="comment">% Dynamixel moving status threshold</span>

        ESC_CHARACTER               = <span class="string">'e'</span>;          <span class="comment">% Key for escaping loop</span>

        COMM_SUCCESS                = 0;            <span class="comment">% Communication Success result value</span>
        COMM_TX_FAIL                = -1001;        <span class="comment">% Communication Tx Failed</span>

        index = 1;
        port_num=0;

        <span class="comment">% a, alpha, d, theta</span>
        dh = [0   	-90	0.0919 0;
            0.096	0       0       0;
            0.096	0	0	0;
            0.047  	0	0	0];

        dh_rad = [0   	-pi/2	0.0919 0;
            0.096	0       0       0;
            0.096	0	0	0;
            0.047  	0	0	0];

        A = zeros(4,4);

        joint_angles = [0 0 0 0];
        joint_pos = zeros(4,4);

        draw_robot_flag = 0;
        rbt = rigidBodyTree;

        joint_limits = [-180 180; -160 0; -80 80; -80 80];

        ik = 0;
        ik_weights = [0.25 0.25 0.25 1 1 1];
        joint_offsets = [170 150+90 150 150];
        joint_angle_error = [0 0 0 0];

    <span class="keyword">end</span>
    <span class="keyword">methods</span>
        <span class="keyword">function</span> self = MyRobot()
            <span class="keyword">if</span> ~libisloaded(self.lib_name)
                [notfound, warnings] = loadlibrary(self.lib_name, <span class="string">'dynamixel_sdk.h'</span>, <span class="string">'addheader'</span>, <span class="string">'port_handler.h'</span>, <span class="string">'addheader'</span>, <span class="string">'packet_handler.h'</span>);
            <span class="keyword">end</span>
            self.port_num = portHandler(self.DEVICENAME);
            packetHandler();
            <span class="comment">% Open port</span>
            <span class="keyword">if</span> (openPort(self.port_num))
                fprintf(<span class="string">'Succeeded to open the port!\n'</span>);
            <span class="keyword">else</span>
                fprintf(<span class="string">'Failed to open the port!\n'</span>);
                <span class="comment">% Close port</span>
                closePort(self.port_num);
                unloadlibrary(lib_name);


            <span class="keyword">end</span>

            <span class="comment">% Set port baudrate</span>
            <span class="keyword">if</span> (setBaudRate(self.port_num, self.BAUDRATE))
                fprintf(<span class="string">'Succeeded to change the baudrate!\n'</span>);
            <span class="keyword">else</span>
                unloadlibrary(self.lib_name);
                fprintf(<span class="string">'Failed to change the baudrate!\n'</span>);
                input(<span class="string">'Press any key to terminate...\n'</span>);
                <span class="keyword">return</span>;
            <span class="keyword">end</span>
            fprintf(<span class="string">"Initial Joint Angles: "</span>)
            <span class="keyword">for</span> i=1:length(self.motor_ids)
                self.joint_angles(i) = get_position(self, self.motor_ids(i));
                fprintf(<span class="string">'\n[ID:%03d] Pos:%02d'</span>, self.motor_ids(i), self.joint_angles(i));

            <span class="keyword">end</span>
            self.set_speed([0.5,0.3,0.3,0.3]);
            fprintf(<span class="string">"\nSet initial speed to [05, 0.3, 0.3, 0.3]"</span>);
            self.set_torque_limit([1,1,1,1]);
            fprintf(<span class="string">"\nSet initial torque limit to [1 1 1 1]"</span>);
            self.move_j(0,0,0,0);
            self.create_rbt();

        <span class="keyword">end</span>

        <span class="keyword">function</span> create_rbt(self)
            bodies = cell(4,1);
            joints = cell(4,1);
            <span class="keyword">for</span> i = 1:4
                bodies{i} = rigidBody([<span class="string">'body'</span> num2str(i)]);
                joints{i} = rigidBodyJoint([<span class="string">'jnt'</span> num2str(i)],<span class="string">"revolute"</span>);
                joints{i}.PositionLimits = [self.joint_limits(i,1)*pi/180,self.joint_limits(i,2)*pi/180];
                setFixedTransform(joints{i},self.dh_rad(i,:),<span class="string">"dh"</span>);
                bodies{i}.Joint = joints{i};
                <span class="keyword">if</span> i == 1 <span class="comment">% Add first body to base</span>
                    addBody(self.rbt,bodies{i},<span class="string">"base"</span>)
                <span class="keyword">else</span> <span class="comment">% Add current body to previous body by name</span>
                    addBody(self.rbt,bodies{i},bodies{i-1}.Name)
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            self.ik = inverseKinematics(<span class="string">'RigidBodyTree'</span>,self.rbt);
        <span class="keyword">end</span>

        <span class="keyword">function</span> set_speed(self, speeds)
            <span class="keyword">for</span> i=1:length(self.motor_ids)
                <span class="keyword">if</span> speeds(i) &gt; 0 &amp;&amp; speeds(i) &lt;= 1
                    speed = speeds(i)*1023;
                    write2ByteTxRx(self.port_num, self.PROTOCOL_VERSION, self.motor_ids(i), 32, speed);
                    dxl_comm_result = getLastTxRxResult(self.port_num, self.PROTOCOL_VERSION);
                    dxl_error = getLastRxPacketError(self.port_num, self.PROTOCOL_VERSION);
                    <span class="keyword">if</span> dxl_comm_result ~= self.COMM_SUCCESS
                        fprintf(<span class="string">'\n%s'</span>, getTxRxResult(self.PROTOCOL_VERSION, dxl_comm_result));
                    <span class="keyword">elseif</span> dxl_error ~= 0
                        fprintf(<span class="string">'\n%s'</span>, getRxPacketError(self.PROTOCOL_VERSION, dxl_error));
                    <span class="keyword">end</span>
                <span class="keyword">else</span>
                   fprint(<span class="string">"\nMovement speed out of range, enter value between ]0,1]"</span>);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> set_torque_limit(self, torque)
            <span class="keyword">for</span> i=1:length(self.motor_ids)
                <span class="keyword">if</span> torque(i) &gt; 0 &amp;&amp; torque(i) &lt;= 1
                    tor = torque(i)*1023;
                    write2ByteTxRx(self.port_num, self.PROTOCOL_VERSION, self.motor_ids(i), 34, tor);
                    dxl_comm_result = getLastTxRxResult(self.port_num, self.PROTOCOL_VERSION);
                    dxl_error = getLastRxPacketError(self.port_num, self.PROTOCOL_VERSION);
                    <span class="keyword">if</span> dxl_comm_result ~= self.COMM_SUCCESS
                        fprintf(<span class="string">'%s\n'</span>, getTxRxResult(self.PROTOCOL_VERSION, dxl_comm_result));
                    <span class="keyword">elseif</span> dxl_error ~= 0
                        fprintf(<span class="string">'%s\n'</span>, getRxPacketError(self.PROTOCOL_VERSION, dxl_error));
                    <span class="keyword">end</span>
                <span class="keyword">else</span>
                   fprint(<span class="string">"\nTorque limit out of range, enter value between ]0,1]"</span>);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
                <span class="keyword">end</span>

        <span class="keyword">function</span> enable_motors(self)

            <span class="comment">% Enable Dynamixel Torque</span>
            <span class="keyword">for</span> i=1:length(self.motor_ids)
                write1ByteTxRx(self.port_num, self.PROTOCOL_VERSION, self.motor_ids(i), self.ADDR_MX_TORQUE_ENABLE, self.TORQUE_ENABLE);
                dxl_comm_result = getLastTxRxResult(self.port_num, self.PROTOCOL_VERSION);
                dxl_error = getLastRxPacketError(self.port_num, self.PROTOCOL_VERSION);
                <span class="keyword">if</span> dxl_comm_result ~= self.COMM_SUCCESS
                    fprintf(<span class="string">'%s\n'</span>, getTxRxResult(self.PROTOCOL_VERSION, dxl_comm_result));
                <span class="keyword">elseif</span> dxl_error ~= 0
                    fprintf(<span class="string">'%s\n'</span>, getRxPacketError(self.PROTOCOL_VERSION, dxl_error));
                <span class="keyword">else</span>
                    fprintf(<span class="string">'\nDynamixel has been successfully connected, torque mode enabled \n'</span>);
                <span class="keyword">end</span>
            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> deg_present_position = get_position(self, motor_id)
            dxl_present_position = read2ByteTxRx(self.port_num, self.PROTOCOL_VERSION, motor_id, self.ADDR_MX_PRESENT_POSITION);
            deg_present_position = self.rot_to_deg(dxl_present_position);
            dxl_comm_result = getLastTxRxResult(self.port_num, self.PROTOCOL_VERSION);
            dxl_error = getLastRxPacketError(self.port_num, self.PROTOCOL_VERSION);
            <span class="keyword">if</span> dxl_comm_result ~= self.COMM_SUCCESS
                fprintf(<span class="string">'%s\n'</span>, getTxRxResult(self.PROTOCOL_VERSION, dxl_comm_result));
            <span class="keyword">elseif</span> dxl_error ~= 0
                fprintf(<span class="string">'%s\n'</span>, getRxPacketError(self.PROTOCOL_VERSION, dxl_error));
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> disable_motors(self)

            <span class="keyword">for</span> i=1:length(self.motor_ids)

                <span class="comment">% Disable Dynamixel Torque</span>
                write1ByteTxRx(self.port_num, self.PROTOCOL_VERSION, self.motor_ids(i), self.ADDR_MX_TORQUE_ENABLE, self.TORQUE_DISABLE);
                dxl_comm_result = getLastTxRxResult(self.port_num, self.PROTOCOL_VERSION);
                dxl_error = getLastRxPacketError(self.port_num, self.PROTOCOL_VERSION);
                <span class="keyword">if</span> dxl_comm_result ~= self.COMM_SUCCESS
                    fprintf(<span class="string">'%s\n'</span>, getTxRxResult(self.PROTOCOL_VERSION, dxl_comm_result));
                <span class="keyword">elseif</span> dxl_error ~= 0
                    fprintf(<span class="string">'%s\n'</span>, getRxPacketError(self.PROTOCOL_VERSION, dxl_error));
                <span class="keyword">else</span>
                    fprintf(<span class="string">'\nDynamixel succesfully disconnected'</span>);

                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="comment">% Close port</span>
            closePort(self.port_num);

            <span class="comment">% Unload Library</span>
            unloadlibrary(self.lib_name);
        <span class="keyword">end</span>

        <span class="keyword">function</span> deg = check_limits(self,deg, motor_id)
            <span class="comment">% see https://emanual.robotis.com/docs/en/dxl/ax/ax-12a/</span>
            <span class="keyword">if</span> motor_id==self.motor_ids(1)
                <span class="keyword">return</span>
            <span class="keyword">elseif</span> motor_id==self.motor_ids(2)
                assert(deg &lt;= 0 &amp;&amp; deg &gt;= -160, <span class="string">"Angle Limits for second Axis Reached, Min/Max: +-90&deg;"</span>);
            <span class="keyword">else</span>
                assert(abs(deg) &lt;= 80, <span class="string">"Angle Limits Reached, Min/Max: +-90&deg;"</span>);
            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> rot = deg_to_rot(self,deg)
            rot = deg*1/0.29;
        <span class="keyword">end</span>

        <span class="keyword">function</span> deg = rot_to_deg(self,rot)
            deg = rot*0.29;
        <span class="keyword">end</span>

        <span class="keyword">function</span> move_j(self,j1,j2,j3,j4)
            j1 = self.check_limits(j1, self.motor_ids(1));
            j2 = self.check_limits(j2, self.motor_ids(2));
            j3 = self.check_limits(j3, self.motor_ids(3));
            j4 = self.check_limits(j4, self.motor_ids(4));

            self.joint_angles = [j1 j2 j3 0];
            self.forward([j1 j2 j3 0]);
            <span class="keyword">if</span> self.draw_robot_flag
                self.draw_robot()
            <span class="keyword">end</span>
            j1 = j1 + self.joint_offsets(1);
            j2 = j2 + self.joint_offsets(2);
            j3 = j3 + self.joint_offsets(3);
            j4 = j4 + self.joint_offsets(4);


            write2ByteTxRx(self.port_num, self.PROTOCOL_VERSION, self.motor_ids(1), self.ADDR_MX_GOAL_POSITION, self.deg_to_rot(j1));
            write2ByteTxRx(self.port_num, self.PROTOCOL_VERSION, self.motor_ids(2), self.ADDR_MX_GOAL_POSITION, self.deg_to_rot(j2));
            write2ByteTxRx(self.port_num, self.PROTOCOL_VERSION, self.motor_ids(3), self.ADDR_MX_GOAL_POSITION, self.deg_to_rot(j3));
            pause(1)
        <span class="keyword">end</span>


        <span class="keyword">function</span> draw_robot(self)
            self.draw_robot_flag = 1;

            config = homeConfiguration(self.rbt);
            <span class="keyword">for</span> i=1:length(self.joint_angles)
                config(i).JointPosition = self.joint_angles(i)*pi/180;
            <span class="keyword">end</span>
            figure(Name=<span class="string">"RRRR Robot Model"</span>);
            show(self.rbt,config);
        <span class="keyword">end</span>

        <span class="keyword">function</span> ee_cartesian_coords = forward(self, j_a)

            self.A = [cosd(j_a(1)) -sind(j_a(1))*cosd(self.dh(1,2))  sind(j_a(1))*sind(self.dh(1,2)) self.dh(1,1)*cosd(j_a(1));
                sind(j_a(1)) cosd(j_a(1))*cosd(self.dh(1,2)) -cosd(j_a(1))*sind(self.dh(1,2)) self.dh(1,1)*sind(j_a(1));
                0 sind(self.dh(1,2)) cosd(self.dh(1,2)) self.dh(1,3);
                0 0 0 1];

            self.joint_pos(:,1) = self.A * [0 0 0 1]' ;
            self.joint_pos(:,1) = self.joint_pos(:,1) / self.joint_pos(4,1);

            <span class="keyword">for</span> i=2:length(j_a)
                self.A = self.A * [cosd(j_a(i)) -sind(j_a(i))*cosd(self.dh(i,2))  sind(j_a(i))*sind(self.dh(i,2)) self.dh(i,1)*cosd(j_a(i));
                    sind(j_a(i)) cosd(j_a(i))*cosd(self.dh(i,2)) -cosd(j_a(i))*sind(self.dh(i,2)) self.dh(i,1)*sind(j_a(i));
                    0 sind(self.dh(i,2)) cosd(self.dh(i,2)) self.dh(i,3);
                    0 0 0 1];
                self.joint_pos(:,i) = self.A * [0 0 0 1]' ;
                self.joint_pos(:,i) = self.joint_pos(:,i) / self.joint_pos(4,i);
            <span class="keyword">end</span>

            ee_cartesian_coords = self.A * [0 0 0 1]' ;
            ee_cartesian_coords = ee_cartesian_coords/ee_cartesian_coords(4);
        <span class="keyword">end</span>

        <span class="keyword">function</span> j_a = inverse(self, x,y,z)
<span class="comment">%             self.joint_angles(1) = atan2(y,x);</span>
<span class="comment">%</span>
<span class="comment">%             r = sqrt(x^2+y^2);</span>
<span class="comment">%             d = sqrt(r^2+(z-0.091)^2);</span>
<span class="comment">%             h = sqrt(0.096^2-(d/2)^2);</span>
<span class="comment">%             self.joint_angles(2) = atan2(z-0.096,r) + atan2(h,d/2);</span>
<span class="comment">%             self.joint_angles(3) = -180 -2 * atan2(d/2,h);</span>
<span class="comment">%             self.joint_angles(4) = - self.joint_angles(2) - self.joint_angles(3);</span>


            j_a = zeros(4,1);
            initialguess = self.rbt.homeConfiguration;
            tform = [ 1 0 0 x;
                0 0 1 y;
                0 -1 0 z;
                0 0 0 1];

            [configSoln,solnInfo] = self.ik(<span class="string">'body4'</span>,tform,self.ik_weights,initialguess);
            <span class="keyword">if</span> strcmp(solnInfo.Status,<span class="string">'success'</span>)
                <span class="keyword">for</span> i=1:4
                    j_a(i) = configSoln(i).JointPosition*180/pi;
                <span class="keyword">end</span>
            <span class="keyword">elseif</span> strcmp(solnInfo.Status,<span class="string">'best available'</span>)
                fprintf(<span class="string">"Status: '%s', using Angles:\n"</span>, solnInfo.Status);
                <span class="keyword">for</span> i=1:4
                    j_a(i) = configSoln(i).JointPosition*180/pi;
                    fprintf(<span class="string">"%f&deg;  "</span>,configSoln(i).JointPosition*180/pi);
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                fprintf(<span class="string">"Unsuccesfull IK, with status: '%s'"</span>, solnInfo.Status);
            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> j_a = read_joint_angles(self)
            j_a = zeros(4,1);
            <span class="keyword">for</span> i=1:length(self.motor_ids)
                dxl_present_position = read2ByteTxRx(self.port_num, self.PROTOCOL_VERSION, self.motor_ids(i), 36);
                dxl_comm_result = getLastTxRxResult(self.port_num, self.PROTOCOL_VERSION);
                dxl_error = getLastRxPacketError(self.port_num, self.PROTOCOL_VERSION);
                <span class="keyword">if</span> dxl_comm_result ~= self.COMM_SUCCESS
                    fprintf(<span class="string">'%s\n'</span>, getTxRxResult(self.PROTOCOL_VERSION, dxl_comm_result));
                <span class="keyword">elseif</span> dxl_error ~= 0
                    fprintf(<span class="string">'%s\n'</span>, getRxPacketError(self.PROTOCOL_VERSION, dxl_error));
                <span class="keyword">else</span>
                    j_a(i) = self.rot_to_deg(dxl_present_position) - self.joint_offsets(i);
                    self.joint_angle_error(i) = j_a(i)-self.joint_angles(i);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> ee_pos = read_ee_position(self)
           j_a = self.read_joint_angles();
           ee_pos = self.forward(j_a);
        <span class="keyword">end</span>

        <span class="keyword">function</span> move_c (self,x,y,z)
           j_a = self.inverse(x,y,z);
           self.move_j(j_a(1),j_a(2),j_a(3),j_a(4));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">Failed to open the port!
</pre><pre class="codeoutput error">Unrecognized function or variable 'lib_name'.

Error in MyRobot (line 75)
                unloadlibrary(lib_name);
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
classdef MyRobot < handle
    properties
        lib_name = 'dxl_x64_c';
        %if ~libisloaded(lib_name)
        %    [notfound, warnings] = loadlibrary(lib_name, 'dynamixel_sdk.h', 'addheader', 'port_handler.h', 'addheader', 'packet_handler.h');
        %end
        
        % Control table address
        ADDR_MX_TORQUE_ENABLE       = 24;           % Control table address is different in Dynamixel model
        ADDR_MX_GOAL_POSITION       = 30;
        ADDR_MX_PRESENT_POSITION    = 36;
        
        % Protocol version
        PROTOCOL_VERSION            = 1.0;          % See which protocol version is used in the Dynamixel

        motor_ids = [2 1 10 0];
        
        BAUDRATE                    = 1000000;
        DEVICENAME                  = 'COM3';       % Check which port is being used on your controller
        % ex) Windows: 'COM1'   Linux: '/dev/ttyUSB0' Mac: '/dev/tty.usbserial-*'
        
        TORQUE_ENABLE               = 1;            % Value for enabling the torque
        TORQUE_DISABLE              = 0;            % Value for disabling the torque
        DXL_MOVING_STATUS_THRESHOLD = 10;           % Dynamixel moving status threshold
        
        ESC_CHARACTER               = 'e';          % Key for escaping loop
        
        COMM_SUCCESS                = 0;            % Communication Success result value
        COMM_TX_FAIL                = -1001;        % Communication Tx Failed
        
        index = 1;
        port_num=0;
        
        % a, alpha, d, theta
        dh = [0   	-90	0.0919 0;
            0.096	0       0       0;
            0.096	0	0	0;
            0.047  	0	0	0];
        
        dh_rad = [0   	-pi/2	0.0919 0;
            0.096	0       0       0;
            0.096	0	0	0;
            0.047  	0	0	0];
        
        A = zeros(4,4);
        
        joint_angles = [0 0 0 0];
        joint_pos = zeros(4,4);
        
        draw_robot_flag = 0;
        rbt = rigidBodyTree;
        
        joint_limits = [-180 180; -160 0; -80 80; -80 80];
        
        ik = 0;
        ik_weights = [0.25 0.25 0.25 1 1 1];
        joint_offsets = [170 150+90 150 150];
        joint_angle_error = [0 0 0 0];
   
    end
    methods
        function self = MyRobot()
            if ~libisloaded(self.lib_name)
                [notfound, warnings] = loadlibrary(self.lib_name, 'dynamixel_sdk.h', 'addheader', 'port_handler.h', 'addheader', 'packet_handler.h');
            end
            self.port_num = portHandler(self.DEVICENAME);
            packetHandler();
            % Open port
            if (openPort(self.port_num))
                fprintf('Succeeded to open the port!\n');
            else
                fprintf('Failed to open the port!\n');
                % Close port
                closePort(self.port_num);
                unloadlibrary(lib_name);


            end
            
            % Set port baudrate
            if (setBaudRate(self.port_num, self.BAUDRATE))
                fprintf('Succeeded to change the baudrate!\n');
            else
                unloadlibrary(self.lib_name);
                fprintf('Failed to change the baudrate!\n');
                input('Press any key to terminate...\n');
                return;
            end
            fprintf("Initial Joint Angles: ")
            for i=1:length(self.motor_ids)
                self.joint_angles(i) = get_position(self, self.motor_ids(i));
                fprintf('\n[ID:%03d] Pos:%02d', self.motor_ids(i), self.joint_angles(i));

            end
            self.set_speed([0.5,0.3,0.3,0.3]);
            fprintf("\nSet initial speed to [05, 0.3, 0.3, 0.3]");
            self.set_torque_limit([1,1,1,1]);
            fprintf("\nSet initial torque limit to [1 1 1 1]");
            self.move_j(0,0,0,0);
            self.create_rbt();
            
        end
        
        function create_rbt(self)
            bodies = cell(4,1);
            joints = cell(4,1);
            for i = 1:4
                bodies{i} = rigidBody(['body' num2str(i)]);
                joints{i} = rigidBodyJoint(['jnt' num2str(i)],"revolute");
                joints{i}.PositionLimits = [self.joint_limits(i,1)*pi/180,self.joint_limits(i,2)*pi/180];
                setFixedTransform(joints{i},self.dh_rad(i,:),"dh");
                bodies{i}.Joint = joints{i};
                if i == 1 % Add first body to base
                    addBody(self.rbt,bodies{i},"base")
                else % Add current body to previous body by name
                    addBody(self.rbt,bodies{i},bodies{i-1}.Name)
                end
            end 
            self.ik = inverseKinematics('RigidBodyTree',self.rbt);
        end
        
        function set_speed(self, speeds)
            for i=1:length(self.motor_ids)
                if speeds(i) > 0 && speeds(i) <= 1
                    speed = speeds(i)*1023;
                    write2ByteTxRx(self.port_num, self.PROTOCOL_VERSION, self.motor_ids(i), 32, speed);
                    dxl_comm_result = getLastTxRxResult(self.port_num, self.PROTOCOL_VERSION);
                    dxl_error = getLastRxPacketError(self.port_num, self.PROTOCOL_VERSION);
                    if dxl_comm_result ~= self.COMM_SUCCESS
                        fprintf('\n%s', getTxRxResult(self.PROTOCOL_VERSION, dxl_comm_result));
                    elseif dxl_error ~= 0
                        fprintf('\n%s', getRxPacketError(self.PROTOCOL_VERSION, dxl_error));
                    end
                else
                   fprint("\nMovement speed out of range, enter value between ]0,1]"); 
                end
            end
        end
        
        function set_torque_limit(self, torque)
            for i=1:length(self.motor_ids)
                if torque(i) > 0 && torque(i) <= 1
                    tor = torque(i)*1023;
                    write2ByteTxRx(self.port_num, self.PROTOCOL_VERSION, self.motor_ids(i), 34, tor);
                    dxl_comm_result = getLastTxRxResult(self.port_num, self.PROTOCOL_VERSION);
                    dxl_error = getLastRxPacketError(self.port_num, self.PROTOCOL_VERSION);
                    if dxl_comm_result ~= self.COMM_SUCCESS
                        fprintf('%s\n', getTxRxResult(self.PROTOCOL_VERSION, dxl_comm_result));
                    elseif dxl_error ~= 0
                        fprintf('%s\n', getRxPacketError(self.PROTOCOL_VERSION, dxl_error));
                    end
                else
                   fprint("\nTorque limit out of range, enter value between ]0,1]"); 
                end
            end
                end
        
        function enable_motors(self)         
            
            % Enable Dynamixel Torque
            for i=1:length(self.motor_ids)
                write1ByteTxRx(self.port_num, self.PROTOCOL_VERSION, self.motor_ids(i), self.ADDR_MX_TORQUE_ENABLE, self.TORQUE_ENABLE);
                dxl_comm_result = getLastTxRxResult(self.port_num, self.PROTOCOL_VERSION);
                dxl_error = getLastRxPacketError(self.port_num, self.PROTOCOL_VERSION);
                if dxl_comm_result ~= self.COMM_SUCCESS
                    fprintf('%s\n', getTxRxResult(self.PROTOCOL_VERSION, dxl_comm_result));
                elseif dxl_error ~= 0
                    fprintf('%s\n', getRxPacketError(self.PROTOCOL_VERSION, dxl_error));
                else
                    fprintf('\nDynamixel has been successfully connected, torque mode enabled \n');
                end
            end
            
        end
        
        function deg_present_position = get_position(self, motor_id)
            dxl_present_position = read2ByteTxRx(self.port_num, self.PROTOCOL_VERSION, motor_id, self.ADDR_MX_PRESENT_POSITION);
            deg_present_position = self.rot_to_deg(dxl_present_position);
            dxl_comm_result = getLastTxRxResult(self.port_num, self.PROTOCOL_VERSION);
            dxl_error = getLastRxPacketError(self.port_num, self.PROTOCOL_VERSION);
            if dxl_comm_result ~= self.COMM_SUCCESS
                fprintf('%s\n', getTxRxResult(self.PROTOCOL_VERSION, dxl_comm_result));
            elseif dxl_error ~= 0
                fprintf('%s\n', getRxPacketError(self.PROTOCOL_VERSION, dxl_error));
            end
        end
        
        function disable_motors(self)
            
            for i=1:length(self.motor_ids)
                
                % Disable Dynamixel Torque
                write1ByteTxRx(self.port_num, self.PROTOCOL_VERSION, self.motor_ids(i), self.ADDR_MX_TORQUE_ENABLE, self.TORQUE_DISABLE);
                dxl_comm_result = getLastTxRxResult(self.port_num, self.PROTOCOL_VERSION);
                dxl_error = getLastRxPacketError(self.port_num, self.PROTOCOL_VERSION);
                if dxl_comm_result ~= self.COMM_SUCCESS
                    fprintf('%s\n', getTxRxResult(self.PROTOCOL_VERSION, dxl_comm_result));
                elseif dxl_error ~= 0
                    fprintf('%s\n', getRxPacketError(self.PROTOCOL_VERSION, dxl_error));
                else
                    fprintf('\nDynamixel succesfully disconnected');
                    
                end
            end
            % Close port
            closePort(self.port_num);
            
            % Unload Library
            unloadlibrary(self.lib_name);
        end
        
        function deg = check_limits(self,deg, motor_id)
            % see https://emanual.robotis.com/docs/en/dxl/ax/ax-12a/
            if motor_id==self.motor_ids(1)
                return
            elseif motor_id==self.motor_ids(2)
                assert(deg <= 0 && deg >= -160, "Angle Limits for second Axis Reached, Min/Max: +-90°");
            else
                assert(abs(deg) <= 80, "Angle Limits Reached, Min/Max: +-90°");
            end

        end
        
        function rot = deg_to_rot(self,deg)
            rot = deg*1/0.29;
        end
        
        function deg = rot_to_deg(self,rot)
            deg = rot*0.29;
        end
        
        function move_j(self,j1,j2,j3,j4)
            j1 = self.check_limits(j1, self.motor_ids(1));
            j2 = self.check_limits(j2, self.motor_ids(2));
            j3 = self.check_limits(j3, self.motor_ids(3));
            j4 = self.check_limits(j4, self.motor_ids(4));

            self.joint_angles = [j1 j2 j3 0];
            self.forward([j1 j2 j3 0]);
            if self.draw_robot_flag
                self.draw_robot()
            end
            j1 = j1 + self.joint_offsets(1);
            j2 = j2 + self.joint_offsets(2);
            j3 = j3 + self.joint_offsets(3);
            j4 = j4 + self.joint_offsets(4);           

            
            write2ByteTxRx(self.port_num, self.PROTOCOL_VERSION, self.motor_ids(1), self.ADDR_MX_GOAL_POSITION, self.deg_to_rot(j1));
            write2ByteTxRx(self.port_num, self.PROTOCOL_VERSION, self.motor_ids(2), self.ADDR_MX_GOAL_POSITION, self.deg_to_rot(j2));
            write2ByteTxRx(self.port_num, self.PROTOCOL_VERSION, self.motor_ids(3), self.ADDR_MX_GOAL_POSITION, self.deg_to_rot(j3));
            pause(1)
        end
        
        
        function draw_robot(self)
            self.draw_robot_flag = 1;
            
            config = homeConfiguration(self.rbt);
            for i=1:length(self.joint_angles)
                config(i).JointPosition = self.joint_angles(i)*pi/180;
            end
            figure(Name="RRRR Robot Model");
            show(self.rbt,config);
        end
        
        function ee_cartesian_coords = forward(self, j_a)
           
            self.A = [cosd(j_a(1)) -sind(j_a(1))*cosd(self.dh(1,2))  sind(j_a(1))*sind(self.dh(1,2)) self.dh(1,1)*cosd(j_a(1));
                sind(j_a(1)) cosd(j_a(1))*cosd(self.dh(1,2)) -cosd(j_a(1))*sind(self.dh(1,2)) self.dh(1,1)*sind(j_a(1));
                0 sind(self.dh(1,2)) cosd(self.dh(1,2)) self.dh(1,3);
                0 0 0 1];
            
            self.joint_pos(:,1) = self.A * [0 0 0 1]' ;
            self.joint_pos(:,1) = self.joint_pos(:,1) / self.joint_pos(4,1);
            
            for i=2:length(j_a)
                self.A = self.A * [cosd(j_a(i)) -sind(j_a(i))*cosd(self.dh(i,2))  sind(j_a(i))*sind(self.dh(i,2)) self.dh(i,1)*cosd(j_a(i));
                    sind(j_a(i)) cosd(j_a(i))*cosd(self.dh(i,2)) -cosd(j_a(i))*sind(self.dh(i,2)) self.dh(i,1)*sind(j_a(i));
                    0 sind(self.dh(i,2)) cosd(self.dh(i,2)) self.dh(i,3);
                    0 0 0 1];  
                self.joint_pos(:,i) = self.A * [0 0 0 1]' ;
                self.joint_pos(:,i) = self.joint_pos(:,i) / self.joint_pos(4,i);
            end
            
            ee_cartesian_coords = self.A * [0 0 0 1]' ;
            ee_cartesian_coords = ee_cartesian_coords/ee_cartesian_coords(4);
        end
        
        function j_a = inverse(self, x,y,z)
%             self.joint_angles(1) = atan2(y,x);
%             
%             r = sqrt(x^2+y^2);
%             d = sqrt(r^2+(z-0.091)^2);
%             h = sqrt(0.096^2-(d/2)^2);
%             self.joint_angles(2) = atan2(z-0.096,r) + atan2(h,d/2);
%             self.joint_angles(3) = -180 -2 * atan2(d/2,h);
%             self.joint_angles(4) = - self.joint_angles(2) - self.joint_angles(3);


            j_a = zeros(4,1);            
            initialguess = self.rbt.homeConfiguration;           
            tform = [ 1 0 0 x;
                0 0 1 y;
                0 -1 0 z;
                0 0 0 1];
            
            [configSoln,solnInfo] = self.ik('body4',tform,self.ik_weights,initialguess);
            if strcmp(solnInfo.Status,'success')
                for i=1:4
                    j_a(i) = configSoln(i).JointPosition*180/pi;
                end
            elseif strcmp(solnInfo.Status,'best available')
                fprintf("Status: '%s', using Angles:\n", solnInfo.Status);
                for i=1:4
                    j_a(i) = configSoln(i).JointPosition*180/pi;
                    fprintf("%f°  ",configSoln(i).JointPosition*180/pi);
                end
            else
                fprintf("Unsuccesfull IK, with status: '%s'", solnInfo.Status);
            end
               
        end
        
        function j_a = read_joint_angles(self)
            j_a = zeros(4,1);
            for i=1:length(self.motor_ids)
                dxl_present_position = read2ByteTxRx(self.port_num, self.PROTOCOL_VERSION, self.motor_ids(i), 36);
                dxl_comm_result = getLastTxRxResult(self.port_num, self.PROTOCOL_VERSION);
                dxl_error = getLastRxPacketError(self.port_num, self.PROTOCOL_VERSION);
                if dxl_comm_result ~= self.COMM_SUCCESS
                    fprintf('%s\n', getTxRxResult(self.PROTOCOL_VERSION, dxl_comm_result));
                elseif dxl_error ~= 0
                    fprintf('%s\n', getRxPacketError(self.PROTOCOL_VERSION, dxl_error));
                else
                    j_a(i) = self.rot_to_deg(dxl_present_position) - self.joint_offsets(i);
                    self.joint_angle_error(i) = j_a(i)-self.joint_angles(i);
                end 
            end
        end
        
        function ee_pos = read_ee_position(self)
           j_a = self.read_joint_angles();
           ee_pos = self.forward(j_a);
        end
        
        function move_c (self,x,y,z)
           j_a = self.inverse(x,y,z);
           self.move_j(j_a(1),j_a(2),j_a(3),j_a(4));
        end
    end
end




##### SOURCE END #####
--></body></html>